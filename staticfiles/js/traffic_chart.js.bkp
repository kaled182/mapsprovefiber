/**
 * Traffic Chart Module - Professional Grafana Style
 * Gerencia a exibição de gráficos de tráfego de rede para portas
 */

let currentTrafficChart = null;

/**
 * Fecha o modal de gráfico de tráfego e limpa recursos
 */
function closeTrafficModal() {
    const modal = document.getElementById('trafficModal');
    if (modal) {
        modal.classList.add('hidden');
    }

    if (currentTrafficChart) {
        currentTrafficChart.destroy();
        currentTrafficChart = null;
    }
}

/**
 * Formata valores de tráfego para exibição (bps -> Mbps/Gbps apenas)
 */
function formatTrafficValue(value) {
    if (value >= 1000000000) {
        return (value / 1000000000).toFixed(2) + ' Gb/s';
    } else {
        return (value / 1000000).toFixed(2) + ' Mb/s';
    }
}

/**
 * Calcula estatísticas dos dados
 */
function calculateStats(data) {
    const validValues = data.filter(v => v > 0);
    if (validValues.length === 0) return null;

    const sum = validValues.reduce((a, b) => a + b, 0);
    const mean = sum / validValues.length;
    const sorted = [...validValues].sort((a, b) => a - b);
    const p95Index = Math.floor(0.95 * sorted.length);
    const p95 = sorted[p95Index];
    const max = Math.max(...validValues);
    const min = Math.min(...validValues);
    const last = validValues[validValues.length - 1];

    return { mean, p95, max, min, last, count: validValues.length };
}

/**
 * Exibe o modal com gráfico de tráfego para uma porta específica
 */
async function showPortTrafficChart(portId, portName, deviceName) {
    const modal = document.getElementById('trafficModal');
    const loading = document.getElementById('trafficModalLoading');
    const error = document.getElementById('trafficModalError');
    const container = document.getElementById('trafficChartContainer');
    const canvas = document.getElementById('trafficChartCanvas');
    const statsTable = document.getElementById('trafficStatsTable');
    const title = document.getElementById('trafficModalTitle');

    if (!modal || !loading || !error || !container || !canvas || !title) {
        console.error('Elementos do modal de tráfego não encontrados no DOM');
        return;
    }

    // Verificar se o mapa está em fullscreen e mover o modal se necessário
    const fullscreenElement = document.fullscreenElement || 
                             document.webkitFullscreenElement || 
                             document.mozFullScreenElement ||
                             document.msFullscreenElement;
    
    if (fullscreenElement && modal.parentElement !== fullscreenElement) {
        const originalParent = modal.parentElement;
        if (originalParent) {
            originalParent.removeChild(modal);
        }
        fullscreenElement.appendChild(modal);
    }

    // Mostrar modal e loading
    modal.classList.remove('hidden');
    loading.classList.remove('hidden');
    error.classList.add('hidden');
    container.classList.add('hidden');
    title.textContent = `Tráfego - ${deviceName} :: ${portName}`;

    if (currentTrafficChart) {
        currentTrafficChart.destroy();
        currentTrafficChart = null;
    }

    try {
        const response = await fetch(`/zabbix_api/api/port-traffic-history/${portId}/`);
        const data = await response.json();

        if (!response.ok || data.error) {
            let errorMsg = data.error || 'Erro ao buscar histórico de tráfego';
            if (data.details) {
                errorMsg += '\n\n' + data.details;
            }
            throw new Error(errorMsg);
        }

        const hasInData = data.in.history && data.in.history.length > 0;
        const hasOutData = data.out.history && data.out.history.length > 0;

        if (!hasInData && !hasOutData) {
            let errorMsg = 'Nenhum dado de tráfego disponível para esta porta na última hora.';

            if (!data.in.configured && !data.out.configured) {
                errorMsg += '\n\n❌ Itens de tráfego não configurados no banco de dados.';
                errorMsg += '\n\nConfigure os campos "zabbix_item_id_trafego_in" e "zabbix_item_id_trafego_out" no Admin Django.';
            } else if (!data.in.configured) {
                errorMsg += '\n\n⚠️ Item de tráfego de ENTRADA (IN) não configurado.';
            } else if (!data.out.configured) {
                errorMsg += '\n\n⚠️ Item de tráfego de SAÍDA (OUT) não configurado.';
            } else {
                errorMsg += '\n\n⚠️ Itens configurados mas sem dados retornados pelo Zabbix.';
                errorMsg += '\n\nVerifique se os Item IDs estão corretos e se o Zabbix está coletando dados.';
            }

            throw new Error(errorMsg);
        }

        const chartData = prepareChartData(data);
        
        // Ocultar loading e mostrar container
        loading.classList.add('hidden');
        container.classList.remove('hidden');

        const datasets = [];
        const statsData = {};

        if (hasInData) {
            const statsIn = calculateStats(chartData.dataIn);
            statsData['Entrada'] = statsIn;
            datasets.push({
                label: 'Entrada',
                data: chartData.dataIn,
                borderColor: '#73BF69',
                backgroundColor: 'rgba(115, 191, 105, 0.15)',
                borderWidth: 2,
                tension: 0.4,
                fill: true,
                stats: statsIn
            });
        }

        if (hasOutData) {
            const statsOut = calculateStats(chartData.dataOut);
            statsData['Saída'] = statsOut;
            datasets.push({
                label: 'Saída',
                data: chartData.dataOut,
                borderColor: '#5794F2',
                backgroundColor: 'rgba(87, 148, 242, 0.15)',
                borderWidth: 2,
                tension: 0.4,
                fill: true,
                stats: statsOut
            });
        }

        // Adicionar linhas de percentil 95
        if (hasInData && statsData['Entrada']) {
            datasets.push({
                label: '95 Per Entrada',
                data: Array(chartData.labels.length).fill(statsData['Entrada'].p95),
                borderColor: 'rgba(115, 191, 105, 0.5)',
                borderDash: [5, 5],
                borderWidth: 1.5,
                pointRadius: 0,
                fill: false,
                tension: 0
            });
        }

        if (hasOutData && statsData['Saída']) {
            datasets.push({
                label: '95 Per Saída',
                data: Array(chartData.labels.length).fill(statsData['Saída'].p95),
                borderColor: 'rgba(87, 148, 242, 0.5)',
                borderDash: [5, 5],
                borderWidth: 1.5,
                pointRadius: 0,
                fill: false,
                tension: 0
            });
        }

        createTrafficChart(canvas, chartData.labels, chartData.timestamps, datasets);
        
        // Atualizar tabela de estatísticas
        if (statsTable) {
            updateStatsTable(statsTable, statsData);
        }

    } catch (err) {
        loading.classList.add('hidden');
        error.classList.remove('hidden');
        const errorP = error.querySelector('p');
        if (errorP) {
            errorP.textContent = err.message;
        }
        console.error('Erro ao carregar gráfico de tráfego:', err);
    }
}

/**
 * Atualiza a tabela de estatísticas
 */
function updateStatsTable(tableElement, statsData) {
    let html = `
        <table class="w-full text-xs text-gray-300">
            <thead class="border-b border-gray-700">
                <tr class="text-gray-400">
                    <th class="text-left py-2 px-3 font-medium">Name</th>
                    <th class="text-right py-2 px-3 font-medium">Mean</th>
                    <th class="text-right py-2 px-3 font-medium">Last ▼</th>
                    <th class="text-right py-2 px-3 font-medium">Max</th>
                    <th class="text-right py-2 px-3 font-medium">Min</th>
                </tr>
            </thead>
            <tbody>
    `;

    Object.keys(statsData).forEach(name => {
        const stats = statsData[name];
        const color = name === 'Entrada' ? '#73BF69' : '#5794F2';
        
        html += `
            <tr class="border-b border-gray-800 hover:bg-gray-800">
                <td class="py-2 px-3">
                    <span class="inline-block w-3 h-3 rounded-sm mr-2" style="background-color: ${color}"></span>
                    ${name}
                </td>
                <td class="text-right py-2 px-3 font-mono">${formatTrafficValue(stats.mean)}</td>
                <td class="text-right py-2 px-3 font-mono font-semibold">${formatTrafficValue(stats.last)}</td>
                <td class="text-right py-2 px-3 font-mono">${formatTrafficValue(stats.max)}</td>
                <td class="text-right py-2 px-3 font-mono">${formatTrafficValue(stats.min)}</td>
            </tr>
        `;
        
        // Adicionar linha de percentil 95
        html += `
            <tr class="border-b border-gray-800 hover:bg-gray-800">
                <td class="py-2 px-3 pl-8 text-gray-500">
                    <span class="inline-block w-3 h-0.5" style="background-color: ${color}; opacity: 0.5; border-top: 1px dashed ${color}"></span>
                    95 Per ${name}
                </td>
                <td class="text-right py-2 px-3 font-mono text-gray-400">${formatTrafficValue(stats.p95)}</td>
                <td class="text-right py-2 px-3 font-mono text-gray-400">${formatTrafficValue(stats.p95)}</td>
                <td class="text-right py-2 px-3 font-mono text-gray-400">${formatTrafficValue(stats.p95)}</td>
                <td class="text-right py-2 px-3 font-mono text-gray-400">${formatTrafficValue(stats.p95)}</td>
            </tr>
        `;
    });

    html += `
            </tbody>
        </table>
    `;

    tableElement.innerHTML = html;
}

/**
 * Prepara os dados recebidos da API para o formato do Chart.js
 */
function prepareChartData(data) {
    const labels = [];
    const timestamps = [];
    const dataIn = [];
    const dataOut = [];

    const allTimestamps = new Set();

    if (data.in.history) {
        data.in.history.forEach(point => allTimestamps.add(point.timestamp));
    }
    if (data.out.history) {
        data.out.history.forEach(point => allTimestamps.add(point.timestamp));
    }

    const sortedTimestamps = Array.from(allTimestamps).sort((a, b) => a - b);

    const inMap = {};
    const outMap = {};

    if (data.in.history) {
        data.in.history.forEach(point => {
            inMap[point.timestamp] = point.value;
        });
    }

    if (data.out.history) {
        data.out.history.forEach(point => {
            outMap[point.timestamp] = point.value;
        });
    }

    sortedTimestamps.forEach(ts => {
        const date = new Date(ts * 1000);
        labels.push(date.toLocaleTimeString('pt-BR', { 
            hour: '2-digit', 
            minute: '2-digit'
        }));
        timestamps.push(date);
        dataIn.push(inMap[ts] || 0);
        dataOut.push(outMap[ts] || 0);
    });

    return { labels, timestamps, dataIn, dataOut };
}

/**
 * Cria o gráfico de linha estilo Grafana profissional
 */
function createTrafficChart(canvas, labels, timestamps, datasets) {
    const ctx = canvas.getContext('2d');

    currentTrafficChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'index',
                intersect: false
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'bottom',
                    labels: {
                        color: '#D0D0D0',
                        font: {
                            size: 11,
                            family: "'Inter', sans-serif"
                        },
                        padding: 15,
                        usePointStyle: true,
                        pointStyle: 'line',
                        boxWidth: 20,
                        boxHeight: 2
                    }
                },
                tooltip: {
                    enabled: true,
                    backgroundColor: 'rgba(17, 17, 17, 0.95)',
                    titleColor: '#ffffff',
                    bodyColor: '#D0D0D0',
                    borderColor: 'rgba(255, 255, 255, 0.1)',
                    borderWidth: 1,
                    padding: 12,
                    titleFont: { size: 12, weight: '600' },
                    bodyFont: { size: 11, family: "'Roboto Mono', monospace" },
                    callbacks: {
                        title: function(context) {
                            if (timestamps && timestamps[context[0].dataIndex]) {
                                return timestamps[context[0].dataIndex].toLocaleString('pt-BR');
                            }
                            return context[0].label;
                        },
                        label: function(context) {
                            const label = context.dataset.label || '';
                            const value = context.parsed.y;
                            return `${label}: ${formatTrafficValue(value)}`;
                        }
                    }
                }
            },
            scales: {
                x: {
                    grid: {
                        color: 'rgba(255, 255, 255, 0.05)',
                        lineWidth: 1
                    },
                    ticks: {
                        color: '#8B8B8B',
                        font: { size: 10, family: "'Roboto Mono', monospace" },
                        maxRotation: 0,
                        autoSkip: true,
                        maxTicksLimit: 15
                    },
                    border: { display: false }
                },
                y: {
                    beginAtZero: true,
                    grid: {
                        color: 'rgba(255, 255, 255, 0.08)',
                        lineWidth: 1
                    },
                    ticks: {
                        color: '#8B8B8B',
                        font: { size: 10, family: "'Roboto Mono', monospace" },
                        callback: (value) => formatTrafficValue(value)
                    },
                    border: { display: false }
                }
            },
            animation: {
                duration: 300
            }
        }
    });
}

/**
 * Adiciona event listeners aos botões de tráfego
 */
function attachTrafficButtonListeners() {
    setTimeout(() => {
        const trafficButtons = document.querySelectorAll('.traffic-btn');
        trafficButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const portId = btn.getAttribute('data-port-id');
                const portName = btn.getAttribute('data-port-name');
                const deviceName = btn.getAttribute('data-device-name');
                showPortTrafficChart(portId, portName, deviceName);
            });
        });
    }, 100);
}

// Fechar modal ao clicar fora
window.addEventListener('click', (event) => {
    const modal = document.getElementById('trafficModal');
    if (event.target === modal) {
        closeTrafficModal();
    }
});